* Add a boss health bar when the player is in the boss room. If the room contains monsters, display the monster health bar.
* Always display the userâ€™s health bar.
* Prevent the user from attacking bosses or monsters if they do not have the required items.
* Keep the narrative short. Provide brief explanations for each direction and item.
* Replace Deepgram for speech-to-text. Keep Mistral as is. below is the example of deepgram stt usage. i've already have the api key using DEEPGRAM_API_KEY
# Example filename: main.py

# For more Python SDK migration guides, visit:
# https://github.com/deepgram/deepgram-python-sdk/tree/main/docs

# Set your Deepgram API key as an environment variable:
# export DEEPGRAM_API_KEY="your-api-key-here"

import httpx
import logging
import threading

from deepgram import (
    DeepgramClient,
)
from deepgram.core.events import EventType

# URL for the realtime streaming audio you would like to transcribe
URL = "http://stream.live.vc.bbcmedia.co.uk/bbc_world_service"

def main():
    try:
        # use default config
        deepgram: DeepgramClient = DeepgramClient()

        # Create a websocket connection to Deepgram
        with deepgram.listen.v1.connect(model="nova-3", language="en-US", endpointing=300) as connection:
            def on_message(message) -> None:
                msg_type = getattr(message, "type", "Unknown")
                if hasattr(message, 'channel') and hasattr(message.channel, 'alternatives'):
                    sentence = message.channel.alternatives[0].transcript
                    if len(sentence) == 0:
                        return
                    print(message.channel.json(indent=4))

            connection.on(EventType.OPEN, lambda _: print("Connection opened"))
            connection.on(EventType.MESSAGE, on_message)
            connection.on(EventType.CLOSE, lambda _: print("Connection closed"))
            connection.on(EventType.ERROR, lambda error: print(f"Error: {error}"))

            lock_exit = threading.Lock()
            exit = False

            # Define a thread for start_listening with error handling
            def listening_thread():
                try:
                    connection.start_listening()
                except Exception as e:
                    print(f"Error in listening thread: {e}")

            # Start listening in a separate thread
            listen_thread = threading.Thread(target=listening_thread)
            listen_thread.start()

            # define a worker thread for HTTP streaming with error handling
            def myThread():
                try:
                    with httpx.stream("GET", URL) as r:
                        for data in r.iter_bytes():
                            lock_exit.acquire()
                            if exit:
                                break
                            lock_exit.release()

                            connection.send_media(data)
                except Exception as e:
                    print(f"Error in HTTP streaming thread: {e}")

            # start the HTTP streaming thread
            myHttp = threading.Thread(target=myThread)
            myHttp.start()

            # signal finished
            input("")
            lock_exit.acquire()
            exit = True
            lock_exit.release()

            # Wait for both threads to close and join with timeout
            myHttp.join(timeout=5.0)
            listen_thread.join(timeout=5.0)

            print("Finished")

    except Exception as e:
        print(f"Could not open socket: {e}")
        return

if __name__ == "__main__":
    main()

- use the bg image that i've added in the dungeon map data, you can use it as background instead of just black or something, also for the text overlay, if maybe the text can't be seen because of the background, you can add something like border with background fill that make the text can be seen if we use all the background images